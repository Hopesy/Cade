# 技术备注

## 工具调用 vs 思维链

### 工具调用循环（Tool Calling Loop）

这是 OpenAI Function Calling 协议的标准行为，不是"思维链"。

```
用户输入 → 模型决定调用工具A → 执行A → 结果返回模型 
         → 模型决定调用工具B → 执行B → 结果返回模型 
         → 模型决定不再调用 → 输出最终回复
```

- 每次模型只做一个决策："现在该调用什么工具？" 或 "该回复了"
- Semantic Kernel 的 `AutoInvokeKernelFunctions` 自动处理这个循环
- 任何支持 Function Calling 的模型都能做到（deepseek-chat、GPT-4、Claude 等）

### 思维链（Chain of Thought / Reasoning）

这是模型**内部推理**的能力，比如 deepseek-reasoner 会输出 `<think>...</think>` 推理过程。

| 特性 | deepseek-chat | deepseek-reasoner |
|---|---|---|
| 工具调用 | ✅ 支持 | ✅ 支持 |
| 内部推理可见 | ❌ 直接给结果 | ✅ 输出思考过程 |
| 复杂任务表现 | 一般 | 更强 |

### 结论

deepseek-chat 能"一步步调用工具"是因为：
1. 它支持 Function Calling 协议
2. Semantic Kernel 自动循环调用直到模型不再请求工具

如果要支持 deepseek-reasoner，需要额外处理 `reasoning_content` 字段来展示思考过程。

## 思维链显示功能实现

### 使用方式
- 输入 `/reasoning` 命令切换思维链显示开关
- 设置保存在 `appsettings.json` 的 `AppSettings:ShowReasoning`

### 技术实现
1. `IAiService.GetResponseWithReasoningAsync()` - 返回 `AiResponse` 包含 Content 和 ReasoningContent
2. `ProductionAiService` 从 `ChatMessageContent.Metadata` 中尝试获取 `reasoning_content`
3. `ConsoleUserInterface.ShowReasoning()` - 用灰色面板显示思维链内容
4. `MainViewModel.ShowReasoning` / `LastReasoningContent` - 存储设置和内容

### 注意事项
- Semantic Kernel 可能不直接暴露 DeepSeek 的 `reasoning_content` 字段
- 需要检查 `response.Metadata` 中的键名（可能是 `reasoning_content` 或 `ReasoningContent`）
- 如果 Semantic Kernel 不传递此字段，可能需要直接调用 HTTP API
